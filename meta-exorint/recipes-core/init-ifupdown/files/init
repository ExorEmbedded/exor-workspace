#!/bin/bash
### BEGIN INIT INFO
# Provides:          networking
# Required-Start:    mountvirtfs $local_fs
# Required-Stop:     $local_fs
# Should-Start:      ifupdown
# Should-Stop:       ifupdown
# Default-Start:     S
# Default-Stop:      0 6
# Short-Description: Raise network interfaces.
### END INIT INFO

export PATH="/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin"
INTERFACESCONF="/etc/network/interfaces"
RESOLVCONF="/etc/resolv.conf"
PPCMD="`cat /proc/$PPID/comm`"
MODEM_PREV_STATE="0"

[ -x /sbin/ifup ] || exit 0

check_network_file_systems() {
    [ -e /proc/mounts ] || return 0

    if [ -e /etc/iscsi/iscsi.initramfs ]; then
	echo "not deconfiguring network interfaces: iSCSI root is mounted."
	exit 0
    fi

    exec 9<&0 < /proc/mounts
    while read DEV MTPT FSTYPE REST; do
	case $DEV in
	/dev/nbd*|/dev/nd[a-z]*|/dev/etherd/e*)
	    echo "not deconfiguring network interfaces: network devices still mounted."
	    exit 0
	    ;;
	esac
	case $FSTYPE in
	nfs|nfs4|smbfs|ncp|ncpfs|cifs|coda|ocfs2|gfs|pvfs|pvfs2|fuse.httpfs|fuse.curlftpfs)
	    echo "not deconfiguring network interfaces: network file systems still mounted."
	    exit 0
	    ;;
	esac
    done
    exec 0<&9 9<&-
}

# Generate DHCP network configuration based on actual detected interfaces
# (only if file does not already exist)
gen_network_interfaces() {
	[ -r "${INTERFACESCONF}" ] && return 0
	INTERFACESCONFTMP="${INTERFACESCONF}".tmp

	{
		echo "# Generated by /etc/init.d/networking"
		echo "auto lo"
		echo "iface lo inet loopback"
		for interface in /sys/class/net/eth*; do
			IFACE=`basename $interface`;
			echo auto $IFACE;
			echo iface $IFACE inet dhcp
		done

	} > "${INTERFACESCONFTMP}"

    mv "${INTERFACESCONFTMP}" "${INTERFACESCONF}"
}

check_network_swap() {
    [ -e /proc/swaps ] || return 0

    exec 9<&0 < /proc/swaps
    while read DEV MTPT FSTYPE REST; do
	case $DEV in
	/dev/nbd*|/dev/nd[a-z]*|/dev/etherd/e*)
	    echo "not deconfiguring network interfaces: network swap still mounted."
	    exit 0
	    ;;
	esac
    done
    exec 0<&9 9<&-
}

#
# Control interfaces which are not managed by ifplugd
#

start_other() {
	# loopback
	ifconfig lo up  # some services need this (e.g. JMUConfig)
	# bridge
	if [ "${PPCMD}" = "rc" ]; then
		grep -q "^auto br0" $INTERFACESCONF	&& ifup br0 &
	else
		grep -q "^auto br0" $INTERFACESCONF	&& ifup br0
	fi
	# wifi
	if [ "${PPCMD}" = "rc" ]; then
		for wiface in `sys_params network/wifi/autostartInterfaces 2>/dev/null`; do
			dbus-send --print-reply --system --dest=com.exor.EPAD "/ServiceManager" com.exor.EPAD.ServiceManager.command \
					string:"wifi" string:"start" string:"{ \"id\" : \"$wiface\" }" > /dev/null
		done
	else
		dbus-send --print-reply --system --dest=com.exor.EPAD "/ServiceManager" com.exor.EPAD.ServiceManager.command \
				string:"wifi" string:"start" string:"{ \"preserve\" : true }" > /dev/null
	fi
	# [modem]
	if [ "${PPCMD}" = "rc" ]; then
		# resolv.conf settings are linked to /tmp while running, so restore original 
		# config in case of reboot
		if [ -h $RESOLVCONF -a -e $RESOLVCONF.ppporig ]; then
			mv $RESOLVCONF.ppporig $RESOLVCONF
		fi 
		if [ "$(/usr/bin/sys_params services/mobile/autostart 2>/dev/null)" = "true" ]; then
			if dbus-send --print-reply=literal --system --dest=com.exor.EPAD "/ServiceManager" \
				com.exor.EPAD.ServiceManager.controlled string:"mobile" | grep -q "boolean true"; then
				echo "Mobile Service controlled externally - doing nothing"
			else
				/usr/bin/modem start &
			fi
		fi
	else
		if [ "$(/usr/bin/sys_params services/mobile/enabled 2>/dev/null)" = "true" ]; then
			/usr/bin/modem start
		fi
	fi
	/usr/bin/sys_params -w services/mobile/enabled "" 2>/dev/null # delete temporary key
}

stop_other() {
	# modem
	/usr/bin/modem stop
	# wifi
	dbus-send --print-reply --system --dest=com.exor.EPAD "/ServiceManager" com.exor.EPAD.ServiceManager.command \
			string:"wifi" string:"stop" string:"{ \"preserve\" : true }" > /dev/null
	# bridge
	grep -q "^auto br0" $INTERFACESCONF	&& ifdown -f br0
	# loopback
	ifconfig lo down
}

do_start() {
	echo -n "Configuring network interfaces... "
	sysctl -e -p /etc/sysctl.conf >/dev/null 2>&1
	gen_network_interfaces

	# detect if triggered by init (not pid 1 because launched by child scripts)
	# and in such case avoid pulling up all interfaces (already done by ifplugd)
	if [ "${PPCMD}" != "rc" ]; then
		/etc/init.d/ifplugd start
	fi
	start_other
}

do_stop() {
	#check_network_file_systems
	#check_network_swap

	echo -n "Deconfiguring network interfaces... "

	/etc/init.d/ifplugd stop
	stop_other

	# give some time for interfaces to be pulled down
	# Note: this could be improved/removed in the future by making EPAD calls
	# synchronous/multiclient (e.g. startDetached calls in impl/generic/services/wifi.cpp)
	sleep 3
}

case "$1" in
start)
    do_start
	echo "done."
	;;

stop)
    do_stop
	echo "done."
	;;

force-reload|restart)
	echo "Running $0 $1 is deprecated because it may not enable again some interfaces"

	do_stop
	do_start

	echo "done."
	;;

*)
	echo "Usage: /etc/init.d/networking {start|stop}"
	exit 1
	;;
esac

exit 0
